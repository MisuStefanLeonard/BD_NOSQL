# Morsa: Scalable Model Management Repository

**Technical Documentation & Architecture Overview**
_Based on the research: "A repository for scalable model management" by J. Sanchez Cuadrado et al._

## 1. Introduction

Model-Driven Engineering (MDE) tools face a critical bottleneck: "The Large Model Problem." Traditional storage formats (XMI, EMF) require loading entire models into memory, causing `OutOfMemory` errors when processing industrial-scale models (millions of elements).

**Morsa** addresses this by implementing a NoSQL-based backend (MongoDB) combined with intelligent client-side strategies. It enables standard modeling tools to access and manipulate massive models transparently, utilizing **Load-On-Demand** and **Distributed Storage**.

## 2. Data Persistence Strategy

The core innovation is the mapping scheme used to translate complex graph-based models into a document store.

### The Mapping Scheme: Document-Per-Object

Morsa abandons the "Model-as-a-Document" approach. Instead, every single model element (Class, Method, Attribute) is stored as a distinct JSON document.

- **Granularity:** Ensures efficient distribution across the cluster.
- **Generic Schema:** Metamodel-independent; capable of storing UML, BPMN, or custom DSLs without schema changes.

**JSON Representation:**

```json
{
  "_id": "morsa://model/ver1/CustomerClass",
  "eClass": "[http://eclipse.org/uml2/5.0.0/UML#//Class](http://eclipse.org/uml2/5.0.0/UML#//Class)",
  "container": "morsa://model/ver1/RootPackage",
  "attributes": {
    "name": "Customer",
    "isAbstract": false
  },
  "references": {
    "ownedAttributes": [
      "morsa://model/ver1/Customer/name",
      "morsa://model/ver1/Customer/id"
    ]
  }
}
```

## 3. Client-Side Caching & Optimization

To mask network latency and improve responsiveness, Morsa implements a sophisticated caching layer directly on the client application.

### Load-On-Demand

The system never loads a whole model into memory at once.

- **Mechanism:** It fetches only the root elements initially. Subsequent elements are loaded only when explicitly requested by the user or a script (Lazy Loading).
- **Benefit:** Instant startup time regardless of model size.

### Intelligent Prefetching

To reduce "chatty" network round-trips, Morsa predicts what data is needed next:

- **Container Prefetching:** When an object is loaded, its direct children are automatically fetched in the same request payload.
- **Reference Prefetching:** Based on usage patterns, objects referenced by the current object are pre-loaded in batches, anticipating the user's traversal path.

### Cache Replacement (LRU)

The client maintains a **fixed-size memory buffer** (e.g., 10,000 objects).

- **Policy:** When the limit is reached, a **Least Recently Used (LRU)** policy evicts the oldest objects.
- **Stability:** This ensures the client's memory footprint remains small and stable, even when browsing a 100GB model.

## 4. Query Processing

Morsa integrates directly with the **Eclipse Modeling Framework (EMF)** to optimize query performance.

- **Query Injection:** High-level API calls (e.g., `model.getAllOfType("Class")`) are intercepted by the Morsa driver.
- **Server-Side Execution:** Instead of fetching all data to the client for local filtering (which is slow), the query is translated into native MongoDB syntax (`db.find(...)`) and executed on the database server.
- **Result:** Only the matching elements are returned over the network, drastically reducing I/O bandwidth usage.

## 5. Scalability & Sharding Architecture

For industrial scenarios, Morsa leverages MongoDB's **Sharded Cluster** features to achieve horizontal scalability.

### Cluster Topology

| Component          | Function                                                                                            |
| :----------------- | :-------------------------------------------------------------------------------------------------- |
| **Shard Servers**  | **Data Layer:** Physical storage nodes. Large models are split into chunks and distributed here.    |
| **Config Servers** | **Metadata Layer:** Store the cluster metadata and map which chunks belong to which shards.         |
| **Query Routers**  | **Interface Layer:** Acts as the entry point for the client, routing requests to the correct shard. |

### Sharding Strategy

The system utilizes **Hashed Sharding** on the Object URI (`_id`).

- **Behavior:** MongoDB computes a hash of the object's ID to assign it to a specific shard chunk.
- **Benefit:** This ensures a **uniform distribution of data**. A single massive model is spread evenly across all available servers (not just one), maximizing parallel processing power and aggregate RAM availability.

## 6. Performance Comparison

A comparison against standard file-based (XMI) and relational (CDO) solutions demonstrates Morsa's advantages.

| Metric           | XMI (File)               | CDO (Relational) | Morsa (NoSQL)                  |
| :--------------- | :----------------------- | :--------------- | :----------------------------- |
| **Startup Time** | Slow (Parses full file)  | Fast             | **Instant** (Lazy Load)        |
| **Memory Usage** | High (Full model in RAM) | Low              | **Configurable** (Fixed Cache) |
| **Scalability**  | None (Single Server)     | Vertical Only    | **Horizontal** (Sharding)      |
| **Large Models** | Fails (OOM Error)        | Good             | **Excellent**                  |

## 7. Conclusion

Morsa demonstrates that **Document-Oriented databases** are superior to Relational and File-based approaches for Model-Driven Engineering. By combining **sharding**, **granular mapping**, and **smart caching**, it effectively solves the scalability challenges of modern industrial modeling.

# Links

- https://www.researchgate.net/profile/Jesus-Sanchez-Cuadrado/publication/257491810_A_repository_for_scalable_model_management/links/568baf0508ae051f9afc5857/A-repository-for-scalable-model-manage - Page 94-100
